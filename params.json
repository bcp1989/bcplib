{"body":"bcplib\r\n======\r\nbcplib is a object-oriented C library of common data structures and algorithms. \r\nThe philosophy of bcplib is to build a easy-to-use, easy-to-extend library.\r\nAnd I also try to make all modules independent so that user may only need\r\na very limit subset of bcplib to run a specific module. The development of\r\nbcplib is motivated by Java SDK. If you are familiar with Java, you can use\r\nbcplib in a way that you use Java.\r\n\r\nCurrently, bcplib is developed and tested in gcc 4. When using bcplib, you need\r\nto make sure the structure alignment strategy in specific Compiler won't \r\ninfluence the function of bcplib.\r\n\r\nBe ware of the number of objects you created. Object in bcplib is space\r\nconsuming, in a 32-bit architecture, a *arraylist* object takes up to 104 bytes.\r\n- - -\r\nHow to use bcplib\r\n=================\r\nThe interface of bcplib is very simple.\r\n\r\nCreate && destroy Object\r\n------------------------\r\n`class_name A = create(class_name);` for \"new\" a Object and \r\n`destory(class_instance);` for \"release\" a Object.\r\n\r\nFor constructors with arguments, there are a set of `create` functions named as\r\n`createN();` where *N* is the number of arguments. Currently, only zero to three\r\narguments are supported. For example, \r\n`class_name a = create1(class_name, argument1_name, argument1_value);`\r\nwill call the specific initialization function with 1 argument.\r\n\r\nFunction call\r\n-------------\r\nIf a class is named A, and there is a instance of A called a, you can use \r\n`a->function_name(a, other_arguments);` to make a function call, remember to \r\nput the instance itself as the first argument of any function call, it's a\r\nnaive way to simulate *this* reference in Java.\r\n\r\nCast\r\n----\r\nJust like Java. If class A extends/inherits class B, you can use a instance \r\nof A where you need a instance of B. You can directly cast A to B. \r\n\r\nFor example, you can have a array of instance of class *collection*, and each \r\ninstance may be a *arraylist*, *linkedlist* or other class that inherits/extends\r\nfrom *collection*.\r\n\r\nThere are two ways to cast a object from one class to another. You can just type\r\neither `(class_A_name) class_B_instance_var` or \r\n`cast(class_A_name, class_B_instance_var)`\r\nto cast a instance variable of class B to class A. The different is that the\r\nlater one will do the type check.\r\n\r\nClass Type\r\n----------\r\nEvery object has a class type structure to indicate the type of the object.\r\nTo check if a object is exactly the instance of a class, use\r\n`instanceof`. To check if a object inherits/extends or is a instance of a class,\r\nuse `kindof`.\r\n\r\nConventions for developing bcplib\r\n---------------------------------\r\n1. The construction and deconstruction function should be named as\r\n   `class_name_create();` and `class_name_destroy(id obj);`, for constructors\r\n   with arguments, the name should be\r\n   `class_name_create_by_arg1_name_arg2_name(arg1, arg2);`\r\n2. There should be a class_name_prototype macro used to be inherited. For a \r\n   example of the macro, please see \\<bcplib/container/arraylist.h\\>\r\n3. Structure name should not be the same with the class name.\r\n4. Call `DEFINE_CLASS` at header file, and call `INIT_CLASS` in the source file.\r\n   Please see any class inside bcplib for more detail.\r\n\r\nOO in bcplib\r\n============\r\nLike Java, bcplib support concepts of class, single inherit/extends, interface, \r\nabstract class, final class. However, some of the concepts are not 100% the same \r\nas Java. Especially, the concept *inherit* and *extend* in bcplib are different.\r\n\r\nThings to know before start\r\n---------------------------\r\nThe internal represent of bcplib may be complicated, however, to provide a easy-\r\nto-use library, the interface of bcplib is very simple, even, a little bit \r\nincompatible with the \"normal\" rule of software development. \r\n+ *id*, a universal pointers to *Object* in bcplib, just like *id* in \r\n  Objective-C. Nearly every *Object Function* takes a *id* as input, to simulate\r\n  the *this* reference. Inside each *Object Function*, the function first cast \r\n  the *id* to the type it needs so that user don`t have to do the cast when use\r\n  a function of parent class. \r\n+ Every class type is a pointer type. For example, \"arraylist\" is actually\r\n  \"arraylist_t \\*\". You can also use your own way to allocate the structure and\r\n  use initialize a class instead of create function. For example, normally, you\r\n  write `arraylist a = arraylist_create();`, here *a* is a pointer type; and you\r\n  can also write `arraylist_t a;` and then use `arraylist_init(&a);` to\r\n  initialize it, here *a* is a structure type.\r\n\r\nClass\r\n-----\r\nIn bcplib, each class is actually a structure. Every class in bcplib *extends* \r\nthe root class *Object*. We need the following things to define a class:\r\n+ A *prototype* of class, defined by using a macro.\r\n+ Definition for each function type.\r\n+ Functions to *create* and *destroy* a class.\r\n+ Functions to *initialize* and *finalize* a class.\r\n\r\nPrototype\r\n---------\r\nIn order to let others inherits/extends itself, one *Class* should define a \r\nprototype of itself. The prototype is defined by using a macro, simply list all \r\ndata and functions.\r\n\r\nInherit\r\n-------\r\nIn bcplib, inherit is just use another set of functions to initialize a class.\r\nIf class A inherits class B, A cannot have any function or data that B does not \r\nhave. For example, function *arraylist_create_list_iterator* in *arraylist.c* \r\ncreate a anonymous class that inherits class *list_iterator* by initializing the\r\nclass with some functions defined in *arraylist.c*.\r\n\r\nExtends\r\n-------\r\nExtends in bcplib is like Java. Class A extends class B means that A has all\r\nfunction declarations and data that B has, and A may has its own functions or \r\ndata that B does not have. In the prototype of A, the prototype of B should be \r\nthe first element so that we can cast A to B. However, this trick way is \r\ndepend on the structure alignment strategy in specific Compiler.\r\n\r\nInterface\r\n---------\r\nInterface is just a macro contains data or function lists. A class may includes\r\nthe interface in any position of its prototype except the first one (first \r\nelement is reserved for the prototype of parent class). We cannot cast a class\r\nto the interface it implements. So the concept interface in bcplib is \r\nincomplete compared to Java.\r\n\r\nAbstract class\r\n--------------\r\nYou cannot create a abstract class, so in bcplib, a class without any *create* \r\nor \"destroy\" functions can be treated as a abstract class. User can still \r\nallocate a abstract class and use \"init_xxxx\" function to initialize it, but \r\nit's very dangerous, for the definition of such a abstract class may be \r\nincomplete, any function call may lead unknown error.\r\n\r\nFinal class\r\n-----------\r\nYou cannot extends/inherits a final class in bcplib, since final class does not \r\nhave a prototype as well as *initialize* and *finalize* functions.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"OO C library","name":"bcplib"}