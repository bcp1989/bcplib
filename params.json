{"name":"bcplib","body":"bcplib\r\n======\r\nbcplib is a object-oriented C library of common data structures and algorithms. \r\nThe philosophy of bcplib is to build a easy-to-use, easy-to-extend library.\r\nAnd I also try to make all modules independent so that user may only need\r\na very limit subset of bcplib to run a specific module. The development of\r\nbcplib is motivated by Java SDK. If you are familiar with Java, you can use\r\nbcplib in a way that you use Java.\r\n\r\nCurrently, bcplib is developed and tested in GCC 4 and C99 (well...currently I \r\nonly use variadic macros) standard. When using bcplib, you need to make sure the \r\nstructure alignment strategy in specific Compiler won't influence the function \r\nof bcplib.\r\n\r\nBe ware of the number of objects you created. Object in bcplib is space\r\nconsuming, in a 32-bit architecture, a *arraylist* object takes up to 104 bytes.\r\n- - -\r\nHow to use bcplib\r\n=================\r\nThe interface of bcplib is very simple.\r\n\r\nCreate && destroy Object\r\n------------------------\r\n`class_name A = new(class_name, init_flag, arg1, arg2,...);` to \"new\" a Object \r\nand `destory(class_instance);` to \"release\" a Object. Note that here the \r\n`init_flag` is a hint of the initializer to simulate *override* and the \r\ndeveloper can use it in any way it like.\r\n\r\nFunction call\r\n-------------\r\nIf a class is named A, and there is a instance of A called a, you can use \r\n`a->function_name(a, other_arguments);` to make a function call, remember to \r\nput the instance itself as the first argument of any function call, it's a\r\nnaive way to simulate *this* reference in Java.\r\n\r\nCast\r\n----\r\nJust like Java. If class A extends/inherits class B, you can use a instance \r\nof A where you need a instance of B. You can directly cast A to B. \r\n\r\nFor example, you can have a array of instance of class *collection*, and each \r\ninstance may be a *arraylist*, *linkedlist* or other class that inherits/extends\r\nfrom *collection*.\r\n\r\nThere are two ways to cast a object from one class to another. You can just type\r\neither `(class_A_name) class_B_instance_var` or \r\n`cast(class_A_name, class_B_instance_var)`\r\nto cast a instance variable of class B to class A. The different is that the\r\nlater one will do the type check.\r\n\r\nClass Type\r\n----------\r\nEvery object has a class type structure to indicate the type of the object.\r\n+ To check if a object is exactly the instance of a class, use\r\n    `instanceof`. \r\n+ To check if a object inherits/extends or is a instance of a class,\r\n    use `kindof`. \r\n+ To check whether a c pointer points to a object or something else, use \r\n    `is_object`.\r\n+ To get the class type of a object instance, use `classof`.\r\n+ To get the class type of a given class name, use `class_by_name`.\r\n\r\n\r\nConventions for developing bcplib\r\n---------------------------------\r\nPlease see convention.md for the latest convention list.\r\n+ User must define a 'X_prototype' macro which includes all attributes and\r\n    methods for their class.\r\n+ User must define a 'X_interface' macro which includes all attributes and \r\n    methods for their interface.\r\n+ Inside the prototype, 'extends' should always be the first elements.\r\n+ All macros in upper letters should be used outside function blocks, \r\n    all macros in lower letters should be used inside function blocks.\r\n+ Inside initializer and finalizer functions, 'self' is a keywords can be used\r\n    as a pointer to the object instance, and 'flag' is a extra information to\r\n    decide how to initialize the object instance ('overload'). User can use\r\n    the flag in any way they like (or Please see the class in bcplib for\r\n    recommend style). Note that 'INIT_DEFAULT' is preserved to indicate the\r\n    default initializer and its value is 0.\r\n    Note that in bcplib, some flag value are conflict with each other, I solve\r\n    it by simply set a priority of flags. Flags with low priority won't valid \r\n    if a flag with higher priority is set.\r\n+ The range of size_t is from -1 to (2^8)^(sizeof(size_t) - 1. If you cast \r\n    size_t into some signed number, -1 will be the max value of the size_t,\r\n    so I preserve the max value to represent -1 so that many functions can be\r\n    benefit it.\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"OO C library"}